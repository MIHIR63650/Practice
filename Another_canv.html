<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zeus Excel</title>

    <link rel="icon" href="excel icon.png" type="image/x-icon">
    <style>
        body {
            background-color: black;
            display: flex;
            text-align: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        canvas {
            width: 100vw;
            height: 100vh;
            background-color: white;
            margin: auto;
        }

        .sidebar {
            position: absolute;
            top: 0;
            right: 0;
            width: 150px;
            height: 200px;
            border-radius: 7px;
            background-color: rgb(0, 0, 0);
            display: flex;
            justify-content: center;
            align-items: center;
        }
    </style>
</head>

<body>
    <canvas></canvas>
    <div class="sidebar" id="sidebar">
        <button onclick="run()">fetch</button>
        <!-- <form action="http://localhost:5208/upload">
            <input type="file" id="myFile" name="filename">
            <input type="submit">
        </form> -->
    </div>
</body>
<script>
    var data = [];


    const canvas = document.querySelector("canvas");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const ctx = canvas.getContext("2d");

    class cell {
        constructor(x, y, text) {
            ctx.fillStyle = "black";
            ctx.font = "15px Arial";
            if (text.length > 13) {
                text = text.slice(0, 13) + "...";
            }
            ctx.fillText(text, x, y);
        }
    }



    class grid {
        width = 150;
        height = 32;
        cella;
        vertical_offsets = {}
        vertical_lines_pos = [];
        horizontal_offsets = {}
        horizontal_lines_pos = [];
        input;
        startpos = 0;
        pagecount = 1;
        isNumberInRange_y(num) {
            for (let i = 0; i < this.vertical_lines_pos.length; i++) {
                if (num >= this.vertical_lines_pos[i] && num <= this.vertical_lines_pos[i] + 10) {
                    return true;
                }
            }
            return false;
        }
        isNumberInRange_x(num) {
            for (let i = 0; i < this.horizontal_lines_pos.length; i++) {
                if (num >= this.horizontal_lines_pos[i] && num <= this.horizontal_lines_pos[i] + 15) {
                    return true;
                }
            }
            return false;
        }
        removeinput() {
            if (document.getElementById("input")) {
                document.getElementById("input").remove();
                this.refresh();
            }
        }
        fillgrid(offset_vscroll = 0) {
            if (offset_vscroll > 0) {
                this.startpos++;
            } else if (offset_vscroll < 0) {
                this.startpos = Math.max(0, this.startpos - 1);
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "rgba(0, 255, 48, 0.25)";
            ctx.fillRect(0, this.height, this.width, canvas.height);
            ctx.fillRect(this.width, 0, canvas.width, this.height);
            ctx.beginPath();
            let offset_y = 0;
            let offset_x = 0;
            ctx.moveTo(0, 0.5 + this.height);
            ctx.lineTo(canvas.width, 0.5 + this.height);
            ctx.style = "rgba(0, 0, 0, 0.5)";
            ctx.stroke();
            this.cella = new cell(this.width / 2, 22 + this.height, 1 + this.startpos);
            this.vertical_lines_pos[1] = this.height;

            for (let i = 0; i < canvas.width / this.width; i++) {
                if (this.horizontal_offsets[i]) {
                    offset_x += this.horizontal_offsets[i];
                }
                this.horizontal_lines_pos[i] = this.width * i + offset_x;
                ctx.moveTo(0.5 + i * this.width + offset_x, 0);
                ctx.lineTo(0.5 + i * this.width + offset_x, canvas.height);
                ctx.stroke();
                if (i > 0) {
                    this.cella = new cell(this.width * (i) + offset_x + 10, this.height / 2 + 7, String.fromCharCode(64 + i % 26));
                }
            }


            for (let i = 2; i < canvas.height / this.height; i++) {
                if (this.vertical_offsets[i + this.startpos]) {
                    offset_y += this.vertical_offsets[i + this.startpos];
                }
                this.vertical_lines_pos[i] = this.height * i + offset_y;
                ctx.moveTo(0, 0.5 + (i) * this.height + offset_y);
                ctx.lineTo(canvas.width, 0.5 + (i) * this.height + offset_y);
                ctx.stroke();

                this.cella = new cell(this.width / 2, 22 + this.height * (i) + offset_y, i + this.startpos);
            }

        }

        getcell(x, y) {
            let leny = this.vertical_lines_pos.length - 1;
            let lenx = this.horizontal_lines_pos.length - 1;
            let vertical = 1;
            let horizontal = 1;
            for (let i = 0; i < leny; i++) {
                if (y >= this.vertical_lines_pos[i] && y <= this.vertical_lines_pos[i + 1]) {
                    vertical = i
                }
            }
            for (let i = 0; i < lenx; i++) {
                if (x >= this.horizontal_lines_pos[i] && x <= this.horizontal_lines_pos[i + 1]) {
                    horizontal = i
                }
            }

            return [vertical, horizontal];
        }

        filldata() {
            let x = this.width;
            let y = this.height;
            for (let i = 0; i < data.length; i++) {
                let offset_y = 0;
                if (this.vertical_offsets[i + 2 + this.startpos]) {
                    offset_y += this.vertical_offsets[i + 2 + this.startpos];
                }
                let obj = data[i + this.startpos];
                let j = 1;
                for (let key in obj) {
                    this.cella = new cell(this.horizontal_lines_pos[j] + 10, y + 22, obj[key]);
                    x += this.width;

                    j++;
                }
                x = this.width;
                y += (this.height + offset_y);
            }
        }
        highlight_multiple(startCellx, startCelly, endCellx, endCelly) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            this.fillgrid();

            this.filldata();
            ctx.fillStyle = "rgba(0, 255, 48, 0.25)";
            ctx.fillRect(this.horizontal_lines_pos[startCellx], this.vertical_lines_pos[startCelly], (this.horizontal_lines_pos[endCellx + 1] - this.horizontal_lines_pos[startCellx]), (this.vertical_lines_pos[endCelly + 1] - this.vertical_lines_pos[startCelly]));
            ctx.strokeRect(this.horizontal_lines_pos[startCellx], this.vertical_lines_pos[startCelly], (this.horizontal_lines_pos[endCellx + 1] - this.horizontal_lines_pos[startCellx]), (this.vertical_lines_pos[endCelly + 1] - this.vertical_lines_pos[startCelly]));
            ctx.fillRect(0, this.vertical_lines_pos[startCelly], this.width, (this.vertical_lines_pos[endCelly + 1] - this.vertical_lines_pos[startCelly]));
            ctx.strokeRect(0, this.vertical_lines_pos[startCelly], this.width, (this.vertical_lines_pos[endCelly + 1] - this.vertical_lines_pos[startCelly]));
            ctx.fillRect(this.horizontal_lines_pos[startCellx], 0, (this.horizontal_lines_pos[endCellx + 1] - this.horizontal_lines_pos[startCellx]), this.height);
            ctx.strokeRect(this.horizontal_lines_pos[startCellx], 0, (this.horizontal_lines_pos[endCellx + 1] - this.horizontal_lines_pos[startCellx]), this.height);

        }

        refresh() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            this.fillgrid();
            this.filldata();
        }

        resizerows(rowid, height) {
            this.vertical_offsets[rowid + this.startpos] = height;

            this.fillgrid();
            this.filldata();
        }
        resizecols(colid, width) {
            this.horizontal_offsets[colid] = width;

            this.fillgrid();
            this.filldata();
        }

        constructor() {
            this.fillgrid();
            this.filldata();
        }

        scrolldown(ofs) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (this.startpos != 0 && this.startpos % 100 == 0) {
                console.log("fetching data");
                this.pagecount++;
                const fetchapi = fetch(`http://localhost:5208/upload?page=${this.pagecount}`).then((res) => res.json()).then((result) => {
                    console.log(result);
                    data = data.concat(result);
                }).catch((err) => {
                    alert("Error fetching data");
                    console.log(err)
                });
            }
            this.fillgrid(ofs);
            this.filldata();
        }

        editcell(cell) {
            if (cell[0] > 0 && cell[1] > 0) {
                this.refresh();
                this.input = document.createElement("input");
                this.input.type = "text";
                this.input.style.position = "absolute";
                this.input.style.left = this.horizontal_lines_pos[cell[1]] + 6 + "px";
                this.input.style.top = this.vertical_lines_pos[cell[0]] + 5 + "px";
                this.input.style.width = (this.horizontal_lines_pos[cell[1] + 1] - this.horizontal_lines_pos[cell[1]]) - 5 + "px";
                this.input.style.height = (this.vertical_lines_pos[cell[0] + 1] - this.vertical_lines_pos[cell[0]]) + "px";
                this.input.style.border = "3px solid black";
                this.input.style.textAlign = "center";
                if (data[cell[0] - 1 + this.startpos] && data[cell[0] - 1 + this.startpos][Object.keys(data[cell[0] - 2])[cell[1] - 1]]) {
                    this.input.value = data[cell[0] - 1 + this.startpos][Object.keys(data[cell[0] - 2])[cell[1] - 1]];
                }
                this.input.id = "input";
                document.body.appendChild(this.input);
                this.input.focus()
            }
        }
    }


    const run = () => {
        const fetchapi = fetch("http://localhost:5208/upload").then((res) => res.json()).then((result) => {
            document.getElementById("sidebar").style.display = "none";
            data = result;
            let c = new grid();
            let isdragging = false;
            let isresizingrows = false;
            let isresizingcols = false;
            let startx, starty, start, end, initpos_y = 0, initpos_x = 0;

            canvas.addEventListener("mousedown", (e) => {
                initpos_y = 0;
                initpos_x = 0;
                startx = e.clientX;
                starty = e.clientY;
                start = c.getcell(startx, starty);
                if (e.clientX > c.width && e.clientY > c.height) {
                    isdragging = true;
                    c.highlight_multiple(start[1], start[0], start[1], start[0]);
                } else if (e.clientX < c.width) {
                    if ((c.isNumberInRange_y(e.clientY))) {
                        isresizingrows = true;
                        if (c.vertical_offsets[start[0] + c.startpos]) {
                            initpos_y = c.vertical_offsets[start[0] + c.startpos];
                        }
                    }
                } else {
                    if (c.isNumberInRange_x(e.clientX)) {
                        isresizingcols = true;
                        if (c.horizontal_offsets[start[1]]) {
                            initpos_x = c.horizontal_offsets[start[1]];
                        }
                    }
                }
            });



            canvas.addEventListener("mousemove", (e) => {
                if ((e.clientX < c.width) && (c.isNumberInRange_y(e.clientY))) {
                    canvas.style.cursor = "row-resize";
                } else if ((e.clientY < c.height) && (c.isNumberInRange_x(e.clientX))) {
                    canvas.style.cursor = "col-resize";
                }
                else {
                    if (isresizingrows) {


                        canvas.style.cursor = "row-resize";
                    }
                    if (isresizingcols) {
                        canvas.style.cursor = "col-resize";
                    } else {
                        canvas.style.cursor = "cell";
                    }
                }
                if (isresizingrows) {
                    if (start[0] > 1) {
                        c.resizerows(start[0], Math.max(0, e.clientY - starty + initpos_y));
                    }
                } else if (isresizingcols) {
                    if (start[1] > 1) {
                        c.resizecols(start[1], Math.max(0, e.clientX - startx + initpos_x));
                    }
                }
                else {
                    if (isdragging) {
                        end = c.getcell(e.clientX, e.clientY);
                        const [startCellx, endCellx] = [start[1], end[1]].sort((a, b) => a - b);
                        const [startCelly, endCelly] = [start[0], end[0]].sort((a, b) => a - b);
                        c.highlight_multiple(startCellx, startCelly, endCellx, endCelly);
                    }
                }
            });

            canvas.addEventListener("mouseup", (e) => {
                isdragging = false;
                isresizingrows = false;
                isresizingcols = false;
                canvas.style.cursor = "default";
            });

            canvas.addEventListener('wheel', (e) => {
                c.removeinput();
                c.scrolldown(e.deltaY);
            }, {
                passive: true
            });

            document.addEventListener("dblclick", (e) => {
                c.removeinput();
                let cell = c.getcell(e.clientX, e.clientY);
                c.editcell(cell);
                document.getElementById("input").addEventListener("blur", (e) => {
                    data[cell[0] - 1 + c.startpos][Object.keys(data[cell[0] - 2])[cell[1] - 1]] = e.target.value;
                    c.removeinput();
                });
            });
        }).catch((err) => {
            alert("Error fetching data");
            console.log(err)
        });
    }


</script>

</html>